# run with:
# ```
# python extra/benchmark_c_codegen.py > benchmark.c
# ```

import e3nn_jax as e3nn

from benchmark_python import L, channels, trials

print(
"""// autogenerated with:
// python extra/benchmark_c_codegen.py > benchmark.c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include "e3nn.h"

float randn(void) {
    static int generate = 0;
    static float z0, z1;
    generate = !generate;

    if (!generate) {
        return z1;
    }

    float u1, u2;
    do {
        u1 = (float)rand() / RAND_MAX;
        u2 = (float)rand() / RAND_MAX;
    } while (u1 <= 1e-7f);  // avoid log(0)

    z0 = sqrtf(-2.0f * logf(u1)) * cosf(2.0f * M_PI * u2);
    z1 = sqrtf(-2.0f * logf(u1)) * sinf(2.0f * M_PI * u2);
    return z0;
}


int main(void) {
""")

for version in ["_v1", "_v2", "_v3"]:
    print(f'    printf("e3nn.c{version.replace("_", " ")}\\n");')
    for lmax in range(1, L):
        irreps1 = e3nn.Irreps.spherical_harmonics(lmax)
        irreps2 = irreps1 * channels
        irrepso = e3nn.tensor_product(irreps1, irreps2)
        print(f'''
        {{
            Irreps* irreps1 = irreps_create("{irreps1}");
            Irreps* irreps2 = irreps_create("{irreps2}");
            Irreps* irrepso = irreps_create("{irrepso}");
            float input1[{irreps1.dim}] = {{ 0 }};
            float input2[{irreps2.dim}] = {{ 0 }};
            float output[{irrepso.dim}] = {{ 0 }};

            for (int i = 0; i < {irreps1.dim}; i++) {{
                input1[i] = randn();
            }}
            for (int i = 0; i < {irreps2.dim}; i++) {{
                input2[i] = randn();
            }}

            // do once to build Clebsch-Gordan cache if necessary
            tensor_product{version}(irreps1, input1,
                                    irreps2, input2,
                                    irrepso, output);

            clock_t start = clock(); 
            for (int trial = 0; trial < {trials}; trial++) {{
                tensor_product{version}(irreps1, input1,
                                        irreps2, input2,
                                        irrepso, output);
            }}
            float elapsed = ((float) clock() - start) / CLOCKS_PER_SEC; 
            printf("{lmax}, %f\\n", elapsed); 

            irreps_free(irreps1);
            irreps_free(irreps2);
            irreps_free(irrepso);
        }}
    ''')

print("""
    return 0;
}
""")